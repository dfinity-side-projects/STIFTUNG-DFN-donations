
// The Bitcoin donation flow is as follows:

// 1. (External) The USER sends money to the CLIENT ADDRESS, a unique Bitcoin
//    address generated by this extension.

// 2. The CLIENT ADDRESS is watched for incoming transactions, and the contained
//    outputs are forwarded to the CENTRAL ADDRESS, including an OP_RETURN output
//    with the CLIENT DFINITY DATA.

// 3. One of three things happen:
//    a. (External) the funds reach the CENTRAL ADDRESS successfully, and are
//       included in the donation campaign.

//    b. A temporary failure (eg low fee, or double-spend) triggers a retry of
//       step 2.

//    c. A permanent failure (eg campaign ended) allows for a refund, sent to an
//       external address.

var bitcore = require('bitcore-lib')

var TX_FEE_MULTIPLIER = 1.5


function BitcoinHelper() {}


BitcoinHelper.prototype.initialize = function(config) {
  // Client configuration:
  this.clientPrivateKey  = bitcore.PrivateKey(config.privateKey)
  this.clientAddress     = this.clientPrivateKey.toAddress()
  this.clientDfinityData = bitcore.util.buffer.hexToBuffer(config.dfinityAddress.slice(2))

  // Central configuration:
  this.centralAddress = bitcore.Address(config.centralAddress)

  // External block explorer configuration:
  this.pollIntervalMs  = config.pollIntervalMs
  this.bitcoinProvider = config.bitcoinProvider

  // Live CLIENT ADDRESS watch+forward timer:
  this.pollTimer = null

  this.startWatching()
}


BitcoinHelper.prototype.startWatching = function() {
  var self = this

  function nextWatchTick() {
    self.tryForwardBTC().then(function() {
      setTimeout(nextWatchTick, self.pollIntervalMs)
    })
  }

  nextWatchTick()
}


BitcoinHelper.prototype.stopWatching = function() {
  clearTimeout(this.pollTimer)
  this.pollTimer = null
}


BitcoinHelper.prototype.tryForwardBTC = function() {
  var self = this

  return Promise.resolve()
    .then(function() {
      return self.getClientUtxos()
    })
    .then(function(utxos) {
      if (utxos.length == 0) return
      var tx = self.makeClientToCentralTx(utxos)

      return self.sendTransaction(tx)
    })
    .catch(function(err) {
      console.error('tryForwardBTC:', err)
    })
}


BitcoinHelper.prototype.getClientUtxos = function() {
  var self = this

  return new Promise(function(resolve, reject) {
    function callback(err, result) {
      err ? reject(err) : resolve(result)
    }

    return self.bitcoinProvider.getUnspentUtxos(self.clientAddress, callback)
  })
}


BitcoinHelper.prototype.sendTransaction = function(tx) {
  var self = this

  return new Promise(function(resolve, reject) {
    function callback(err, result) {
      err ? reject(err) : resolve(result)
    }

    return self.bitcoinProvider.broadcast(tx, callback)
  })
}


BitcoinHelper.prototype.makeClientToCentralTx = function(utxos) {
  const fee = this.calculateFee(utxos)
  const amount = utxoSum(utxos) - fee

  if (amount < 0) {
    throw new Error("Amount is lower than estimated required fee")
  }

  return new bitcore.Transaction()
    .from(utxos)
    .to(this.centralAddress, amount)
    .addData(this.clientDfinityData)
    .sign(this.clientPrivateKey)
}


BitcoinHelper.prototype.calculateFee = function(utxos) {
  // Craft a fake transaction to take advange of Bitcore's fee estimator:
  var bitcoreFee = new bitcore.Transaction()
    .from(utxos)
    .to(this.centralAddress, 0)
    .change(this.clientAddress)
    .addData(this.clientDfinityData)
    .getFee()

  return Math.ceil(bitcoreFee * TX_FEE_MULTIPLIER)
}


function utxoSum(utxos) {
  return utxos.reduce(function(total, nextUtxo) {
    return total + nextUtxo.satoshis
  }, 0)
}

