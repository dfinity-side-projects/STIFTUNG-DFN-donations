
// The Bitcoin donation flow is as follows:

// 1. (External) The USER sends money to the CLIENT ADDRESS, a unique Bitcoin
//    address generated by this extension.

// 2. The CLIENT ADDRESS is watched for incoming transactions, and the contained
//    outputs are forwarded to the CENTRAL ADDRESS, including an OP_RETURN output
//    with the CLIENT DFINITY DATA.

// 3. One of three things happen:
//    a. (External) the funds reach the CENTRAL ADDRESS successfully, and are
//       included in the donation campaign.

//    b. A temporary failure (eg low fee, or double-spend) triggers a retry of
//       step 2.

//    c. A permanent failure (eg campaign ended) allows for a refund, sent to an
//       external address.

var bitcore = require('bitcore-lib')

var TX_FEE_MULTIPLIER = 1.5


function BitcoinHelper() {}


BitcoinHelper.prototype.initialize = function(config) {
  // Client configuration:
  this.clientPrivateKey  = bitcore.PrivateKey(config.privateKey)
  this.clientAddress     = this.clientPrivateKey.toAddress()
  this.clientDfinityData = bitcore.util.buffer.hexToBuffer(config.dfinityAddress.slice(2))

  // Central configuration:
  this.centralAddress = bitcore.Address(config.centralAddress)

  // External block explorer configuration:
  this.pollIntervalMs  = config.pollIntervalMs
  this.bitcoinProvider = config.bitcoinProvider

  // Live CLIENT ADDRESS watch+forward timer:
  this.pollTimer = null

  this.startWatching()
}


BitcoinHelper.prototype.startWatching = function() {
  var self = this

  function nextWatchTick() {
    self.tryForwardBTC().then(function() {
      setTimeout(nextWatchTick, self.pollIntervalMs)
    })
  }

  nextWatchTick()
}


BitcoinHelper.prototype.stopWatching = function() {
  clearTimeout(this.pollTimer)
  this.pollTimer = null
}


BitcoinHelper.prototype.tryForwardBTC = function() {
  var self = this

  return Promise.resolve()
    .then(function() {
      return self.getClientUtxos()
    })
    .then(function(utxos) {
      if (utxos.length == 0) return
      var tx = self.makeClientToCentralTx(utxos)

      return self.sendTransaction(tx)
    })
    .catch(function(err) {
      console.error('tryForwardBTC:', err)
    })
}


BitcoinHelper.prototype.getClientUtxos = function() {
  var self = this

  return new Promise(function(resolve, reject) {
    function callback(err, result) {
      err ? reject(err) : resolve(result)
    }

    return self.bitcoinProvider.getUnspentUtxos(self.clientAddress, callback)
  })
}


BitcoinHelper.prototype.sendTransaction = function(tx) {
  var self = this

  return new Promise(function(resolve, reject) {
    function callback(err, result) {
      err ? reject(err) : resolve(result)
    }

    return self.bitcoinProvider.broadcast(tx, callback)
  })
}


BitcoinHelper.prototype.makeClientToCentralTx = function(utxos) {
  const fee = Math.floor(this.calculateFee(utxos) * TX_FEE_MULTIPLIER)
  const amount = utxoSum(utxos) - fee

  if (amount < 0) {
    throw new Error("Amount is lower than estimated required fee")
  }

  return new bitcore.Transaction()
    .from(utxos)
    .to(this.centralAddress, amount)
    .addData(this.clientDfinityData)
    .sign(this.clientPrivateKey)
}


BitcoinHelper.prototype.calculateFee = function(utxos) {
  return new bitcore.Transaction()
    .from(utxos)
    .to(this.centralAddress, 0)
    .change(this.clientAddress)
    .addData(this.clientDfinityData)
    .getFee()
}


BitcoinHelper.prototype.makeExternalToClientTx = function() {
  // Move funds from an external testnet source to our client address
  var sourcePk = bitcore.PrivateKey('675a600b9e90ff786fd7966b3a0b84ba787d88ab57cafa4242a28d080f894271')
  var amount = 1e8

  const utxo = bitcore.Transaction.UnspentOutput(    {
        "address": "mpraKTVqqgTxUpYDu1yHakrGLogRcYt5Xo",
        "amount": 47.9992,
        "confirmations": 1,
        "height": 1057233,
        "satoshis": 4799920000,
        "scriptPubKey": "76a914666f1b58521631cd03d0562e631858cce7db8c0488ac",
        "txid": "dbb3bbbbea050cd7e080756d78ddb5a5e3a8d685bac9591c4046d9de71aa4a36",
        "vout": 1
    })

  return new bitcore.Transaction()
    .from(utxo)
    .to(this.clientAddress, amount)
    .change(sourcePk.toAddress())
    .sign(sourcePk)
    .toString('hex')
}


function utxoSum(utxos) {
  return utxos.reduce(function(total, nextUtxo) {
    return total + nextUtxo.satoshis
  }, 0)
}

